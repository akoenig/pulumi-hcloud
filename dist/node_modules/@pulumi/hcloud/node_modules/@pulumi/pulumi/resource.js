"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./errors");
const resource_1 = require("./runtime/resource");
const utils = require("./utils");
/**
 * Resource represents a class whose CRUD operations are implemented by a provider plugin.
 */
class Resource {
    /**
     * Creates and registers a new resource object.  [t] is the fully qualified type token and
     * [name] is the "name" part to use in creating a stable and globally unique URN for the object.
     * dependsOn is an optional list of other resources that this resource depends on, controlling
     * the order in which we perform resource operations.
     *
     * @param t The type of the resource.
     * @param name The _unique_ name of the resource.
     * @param custom True to indicate that this is a custom resource, managed by a plugin.
     * @param props The arguments to use to populate the new resource.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(t, name, custom, props = {}, opts = {}) {
        /**
         * A private field to help with RTTI that works in SxS scenarios.
         */
        // tslint:disable-next-line:variable-name
        /* @internal */ this.__pulumiResource = true;
        if (opts.parent && !Resource.isInstance(opts.parent)) {
            throw new Error(`Resource parent is not a valid Resource: ${opts.parent}`);
        }
        if (!t) {
            throw new errors_1.ResourceError("Missing resource type argument", opts.parent);
        }
        if (!name) {
            throw new errors_1.ResourceError("Missing resource name argument (for URN creation)", opts.parent);
        }
        // Check the parent type if one exists and fill in any default options.
        this.__providers = {};
        if (opts.parent) {
            this.__parentResource = opts.parent;
            this.__parentResource.__childResources = this.__parentResource.__childResources || new Set();
            this.__parentResource.__childResources.add(this);
            if (opts.protect === undefined) {
                opts.protect = opts.parent.__protect;
            }
            this.__providers = opts.parent.__providers;
            if (custom) {
                const provider = opts.provider;
                if (provider === undefined) {
                    opts.provider = opts.parent.getProvider(t);
                }
                else {
                    // If a provider was specified, add it to the providers map under this type's package so that
                    // any children of this resource inherit its provider.
                    const typeComponents = t.split(":");
                    if (typeComponents.length === 3) {
                        const pkg = typeComponents[0];
                        this.__providers = Object.assign({}, this.__providers, { [pkg]: provider });
                    }
                }
            }
        }
        if (!custom) {
            const providers = opts.providers;
            if (providers) {
                this.__providers = Object.assign({}, this.__providers, providers);
            }
        }
        this.__protect = !!opts.protect;
        if (opts.id) {
            // If this resource already exists, read its state rather than registering it anew.
            if (!custom) {
                throw new errors_1.ResourceError("Cannot read an existing resource unless it has a custom provider", opts.parent);
            }
            resource_1.readResource(this, t, name, props, opts);
        }
        else {
            // Kick off the resource registration.  If we are actually performing a deployment, this
            // resource's properties will be resolved asynchronously after the operation completes, so
            // that dependent computations resolve normally.  If we are just planning, on the other
            // hand, values will never resolve.
            resource_1.registerResource(this, t, name, custom, props, opts);
        }
    }
    static isInstance(obj) {
        return utils.isInstance(obj, "__pulumiResource");
    }
    // getProvider fetches the provider for the given module member, if any.
    getProvider(moduleMember) {
        const memComponents = moduleMember.split(":");
        if (memComponents.length !== 3) {
            return undefined;
        }
        const pkg = memComponents[0];
        return this.__providers[pkg];
    }
}
exports.Resource = Resource;
Resource.doNotCapture = true;
/**
 * CustomResource is a resource whose create, read, update, and delete (CRUD) operations are managed
 * by performing external operations on some physical entity.  The engine understands how to diff
 * and perform partial updates of them, and these CRUD operations are implemented in a dynamically
 * loaded plugin for the defining package.
 */
class CustomResource extends Resource {
    /**
     * Returns true if the given object is an instance of CustomResource.  This is designed to work even when
     * multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        return utils.isInstance(obj, "__pulumiCustomResource");
    }
    /**
     * Creates and registers a new managed resource.  t is the fully qualified type token and name
     * is the "name" part to use in creating a stable and globally unique URN for the object.
     * dependsOn is an optional list of other resources that this resource depends on, controlling
     * the order in which we perform resource operations. Creating an instance does not necessarily
     * perform a create on the physical entity which it represents, and instead, this is dependent
     * upon the diffing of the new goal state compared to the current known resource state.
     *
     * @param t The type of the resource.
     * @param name The _unique_ name of the resource.
     * @param props The arguments to use to populate the new resource.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(t, name, props, opts = {}) {
        if (opts.providers) {
            throw new errors_1.ResourceError("Do not supply 'providers' option to a CustomResource. Did you mean 'provider' instead?", opts.parent);
        }
        super(t, name, true, props, opts);
        this.__pulumiCustomResource = true;
    }
}
exports.CustomResource = CustomResource;
CustomResource.doNotCapture = true;
/**
 * ProviderResource is a resource that implements CRUD operations for other custom resources. These resources are
 * managed similarly to other resources, including the usual diffing and update semantics.
 */
class ProviderResource extends CustomResource {
    /**
     * Creates and registers a new provider resource for a particular package.
     *
     * @param pkg The package associated with this provider.
     * @param name The _unique_ name of the provider.
     * @param props The configuration to use for this provider.
     * @param opts A bag of options that control this provider's behavior.
     */
    constructor(pkg, name, props, opts = {}) {
        super(`pulumi:providers:${pkg}`, name, props, opts);
    }
}
exports.ProviderResource = ProviderResource;
/**
 * ComponentResource is a resource that aggregates one or more other child resources into a higher
 * level abstraction. The component resource itself is a resource, but does not require custom CRUD
 * operations for provisioning.
 */
class ComponentResource extends Resource {
    /**
     * Returns true if the given object is an instance of CustomResource.  This is designed to work even when
     * multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        return utils.isInstance(obj, "__pulumiComponentResource");
    }
    /**
     * Creates and registers a new component resource.  [type] is the fully qualified type token and
     * [name] is the "name" part to use in creating a stable and globally unique URN for the object.
     * [opts.parent] is the optional parent for this component, and [opts.dependsOn] is an optional
     * list of other resources that this resource depends on, controlling the order in which we
     * perform resource operations.
     *
     * @param t The type of the resource.
     * @param name The _unique_ name of the resource.
     * @param unused [Deprecated].  Component resources do not communicate or store their properties
     *               with the Pulumi engine.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(type, name, unused, opts = {}) {
        if (opts.provider) {
            throw new errors_1.ResourceError("Do not supply 'provider' option to a ComponentResource. Did you mean 'providers' instead?", opts.parent);
        }
        // Explicitly ignore the props passed in.  We allow them for back compat reasons.  However,
        // we explicitly do not want to pass them along to the engine.  The ComponentResource acts
        // only as a container for other resources.  Another way to think about this is that a normal
        // 'custom resource' corresponds to real piece of cloud infrastructure.  So, when it changes
        // in some way, the cloud resource needs to be updated (and vice versa).  That is not true
        // for a component resource.  The component is just used for organizational purposes and does
        // not correspond to a real piece of cloud infrastructure.  As such, changes to it *itself*
        // do not have any effect on the cloud side of things at all.
        super(type, name, /*custom:*/ false, /*props:*/ {}, opts);
        this.__pulumiComponentResource = true;
    }
    // registerOutputs registers synthetic outputs that a component has initialized, usually by
    // allocating other child sub-resources and propagating their resulting property values.
    // ComponentResources should always call this at the end of their constructor to indicate that
    // they are done creating child resources.  While not strictly necessary, this helps the
    // experience by ensuring the UI transitions the ComponentResource to the 'complete' state as
    // quickly as possible (instead of waiting until the entire application completes).
    registerOutputs(outputs) {
        resource_1.registerResourceOutputs(this, outputs || {});
    }
}
exports.ComponentResource = ComponentResource;
ComponentResource.doNotCapture = true;
ComponentResource.prototype.registerOutputs.doNotCapture = true;
/* @internal */
exports.testingOptions = {
    isDryRun: false,
};
