import { Inputs, Output } from "../output";
import { Resource, ResourceOptions } from "../resource";
/**
 * Reads an existing custom resource's state from the resource monitor.  Note that resources read in this way
 * will not be part of the resulting stack's state, as they are presumed to belong to another.
 */
export declare function readResource(res: Resource, t: string, name: string, props: Inputs, opts: ResourceOptions): void;
/**
 * registerResource registers a new resource object with a given type t and name.  It returns the auto-generated
 * URN and the ID that will resolve after the deployment has completed.  All properties will be initialized to property
 * objects that the registration operation will resolve at the right time (or remain unresolved for deployments).
 */
export declare function registerResource(res: Resource, t: string, name: string, custom: boolean, props: Inputs, opts: ResourceOptions): void;
/**
 * registerResourceOutputs completes the resource registration, attaching an optional set of computed outputs.
 */
export declare function registerResourceOutputs(res: Resource, outputs: Inputs | Promise<Inputs> | Output<Inputs>): void;
